Assignment 3 â€” Minimum Spanning Tree (MST)
ðŸ“˜ Project Description

This project implements and compares two classical algorithms for constructing the Minimum Spanning Tree (MST) of a connected, weighted graph:

Primâ€™s algorithm

Kruskalâ€™s algorithm

Both algorithms are written in Java without using any external graph libraries.
The goal is to analyze their performance on graphs of different sizes and densities, and to evaluate the number of operations, execution time, and resulting total MST cost.

ðŸ§© Code Overview
1. Graph.java

Defines the basic graph structure:

n â€” number of vertices

edges â€” list of all edges

adj â€” adjacency list for Primâ€™s algorithm

Each edge is represented by an Edge object containing:

int u, v, w; // endpoints and weight

2. GraphGenerator.java

Generates connected random graphs using the following steps:

First builds a spanning tree to ensure connectivity.

Then adds random edges until reaching the target number of edges.

Edge weights are random integers between 1 and 100.

3. MSTPrim.java

Implementation of Primâ€™s algorithm using:

A priority queue (PriorityQueue<int[]>) for selecting the smallest edge.

Metrics object for counting operations:

comparisons, pushes, pops.

Returns:

MSTResult(edges, totalCost)

4. MSTKruskal.java

Implementation of Kruskalâ€™s algorithm using:

Edge sorting by weight.

Unionâ€“Find (Disjoint Set) data structure with path compression and union by rank.

Counts metrics for comparisons, unions, and path compressions.

Returns the same MST result format as Primâ€™s algorithm.

5. Metrics.java

Records the number of key operations performed by each algorithm:

comparisons, pushes, pops, unions, pathComp;


and computes the total count via:

operationsCount()

6. Results.java

Contains data classes:

MSTResult â€” stores MST edges and total cost.

ResultRecord â€” combines all information for one graph (Prim + Kruskal results and metrics).

7. JsonIO.java

Handles JSON export:

Converts generated graphs to ass_3_input.json.

Writes MST results and metrics to ass_3_output.json.

Both files follow a clear hierarchical structure:

{
  "results": [
    {
      "graph_id": 1,
      "input_stats": { "vertices": 15, "edges": 40 },
      "prim": { "total_cost": 264, "operations_count": 932, "execution_time_ms": 0.42 },
      "kruskal": { "total_cost": 264, "operations_count": 1020, "execution_time_ms": 0.37 }
    }
  ]
}

8. TestRunner.java

Runs internal validation for all generated graphs:

Ensures Prim and Kruskal give equal MST cost.

Verifies |MST| = V âˆ’ 1.

Prints total passed/failed checks.

9. MSTTests.java

JUnit test suite that checks:

Correctness on a manual small graph.

Equality of Prim and Kruskal on multiple random graphs.

Performance on large graphs.

Handling of disconnected cases.

10. Main.java

The main class controlling the entire experiment:

Generates graphs of 4 categories:

small, medium, large, extra.

Runs Prim and Kruskal on each graph.

Collects results in ass_3_output.json.

Saves metrics to results_summary.csv.

Triggers TestRunner for verification.

ðŸ“Š Output Summary
File	Description
ass_3_input.json	Graphs generated for analysis
ass_3_output.json	Results of both MST algorithms
results_summary.csv	Numerical comparison table (cost, ops, time)
ðŸ§  Key Insights

Primâ€™s algorithm performs better on dense graphs due to adjacency lists and priority queues.

Kruskalâ€™s algorithm is faster on sparse graphs because of efficient edge sorting and unionâ€“find structure.

For all connected graphs, MST total costs are identical.

Execution time and operation counts differ depending on graph density.

âœ¨ Conclusion

This project demonstrates practical differences between Primâ€™s and Kruskalâ€™s algorithms in terms of computational efficiency and implementation structure.
Both algorithms produce the same MST result, but the efficiency trade-off depends on graph size and edge density.
